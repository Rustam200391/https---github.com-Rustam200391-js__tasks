// Задача на нахождение наибольшего/наименьшего элемента в массиве:
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}

// Объяснение: В этой задаче мы инициализируем переменную max первым элементом массива, а затем проходимся по остальным элементам массива, сравнивая их с текущим максимальным значением.

// Задача на проверку палиндрома:
function isPalindrome(str) {
  return str === str.split("").reverse().join("");
}

// Объяснение: Мы разбиваем строку на массив символов с помощью split(''), затем разворачиваем этот массив с помощью reverse() и объединяем обратно в строку с помощью join(''). Если исходная строка равна ее обратному виду, то это палиндром.

// Задача на нахождение суммы всех элементов в массиве:

function sumArray(arr) {
  return arr.reduce((acc, curr) => acc + curr, 0);
}
// Объяснение: Здесь мы используем метод reduce() для суммирования всех элементов массива. Функция обратного вызова складывает текущее значение с аккумулятором.

// Задача на проверку простого числа:

function isPrime(num) {
  if (num <= 1) return false;
  for (let i = 2; i <= Math.sqrt(num); i++) {
    if (num % i === 0) return false;
  }
  return true;
}
// Объяснение: Мы проверяем, делится ли число нацело на любое число от 2 до его квадратного корня. Если да, то число не является простым.

// Задача на обход объекта и вывод ключей и значений:

function printObject(obj) {
  for (let key in obj) {
    console.log(`Key: ${key}, Value: ${obj[key]}`);
  }
}
// Объяснение: Мы используем цикл for...in для обхода всех ключей объекта obj и выводим ключи и соответствующие им значения.

// Задача на подсчет количества вхождений элемента в массиве:
function countOccurrences(arr, target) {
  return arr.reduce((acc, curr) => (curr === target ? acc + 1 : acc), 0);
}
// Объяснение: Мы используем метод reduce() для подсчета количества вхождений элемента target в массив arr.

// Задача на обращение порядка слов в предложении:

function reverseWords(sentence) {
  return sentence.split(" ").reverse().join(" ");
}
// Объяснение: Мы разбиваем предложение на слова с помощью split(' '), разворачиваем массив слов с помощью reverse() и затем объединяем обратно в строку с помощью join(' ').

// Задача на проверку равенства двух объектов:

function isEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;
  for (let key of keys1) {
    if (obj1[key] !== obj2[key]) return false;
  }
  return true;
}
// Объяснение: Мы сначала проверяем, имеют ли объекты одинаковое количество ключей. Затем мы сравниваем значения для каждого ключа.

// Задача на вычисление факториала числа:

function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}
// Объяснение: Это рекурсивная функция, которая вычисляет факториал числа n. Факториал числа n равен произведению всех положительных целых чисел от 1 до n.
// Функция factorial принимает один аргумент n.
// Если n равно 0, возвращается 1, так как факториал 0 по определению равен 1.
// В противном случае, функция вызывает саму себя с аргументом n - 1 и умножает результат на n. Это делается рекурсивно до тех пор, пока n не достигнет 0.

// Задача на поиск индекса элемента в массиве:

function findIndex(arr, target) {
  return arr.indexOf(target);
}
// Объяснение: Мы используем метод indexOf() для поиска индекса элемента target в массиве arr. Если элемент не найден, возвращается -1.
